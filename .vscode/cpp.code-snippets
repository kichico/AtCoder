{
	"UnionFind data structure": {
		"scope": "C++,cpp",
		"prefix": "UnionFind",
		"body": [
			"struct UnionFind {",
				"\tvector<ll> parents;",
				"\tUnionFind(int size) { parents.assign(size, -1); }",
				"\tll findRoot(ll x) {",
					"\t\tif (parents[x] < 0) return x;",
					"\t\treturn parents[x] = findRoot(parents[x]);",
				"\t}",
				"\tbool unite(ll x, ll y) {",
					"\t\tx = findRoot(x);",
					"\t\ty = findRoot(y);",
					"\t\tif (x == y) return false;",
					"\t\tif (parents[x] > parents[y]) swap(x, y);",
					"\t\tparents[x] += parents[y];",
					"\t\tparents[y] = x;",
					"\t\treturn true;",
				"\t}",
				"\tll size(ll x) { return -parents[findRoot(x)]; }",
				"\tbool isSameGroup(ll x, ll y) { return findRoot(x) == findRoot(y); }",
			"};"
			],
	 	"description": "write UnionFind data structure"
	},
	"dijkstra": {
        "scope": "C++,cpp",
		"prefix": "dijkstra",
        "body": [
            "struct Edge{",
            "    ll to,cost;",
            "    Edge() {}",
            "    Edge(ll to, ll cost=0): to(to), cost(cost) {}",
            "};",
            "",
            "typedef pair<ll,ll> P;",
            "struct graph{",
            "    const ll INF=numeric_limits<ll>::max();",
            "    vector<vector<Edge>> G;",
            "    ll n;",
            "    graph(ll N) {",
            "       n=N;",
            "       G.resize(n);",
            "    }",
            "    void add_edge(ll from, ll destination, ll cost) {",
            "       G[from].emplace_back(destination,cost); ",
            "    }",
            "    pair<vector<ll>,vector<ll>> dijkstra(ll start) {",
            "       vector<ll> dist(n,INF);",
            "       vector<ll> path(n,-1);",
            "       priority_queue<P,vector<P>,greater<P>> que;",
            "       dist[start]=0;",
            "       que.emplace(0,start);",
            "       while(!que.empty()){",
            "           P p=que.top();",
            "           que.pop();",
            "           ll v=p.second;",
            "           ll min_dist=p.first;",
            "           if(dist[v]<min_dist) continue;",
            "           for(Edge& edge:G[v]){",
            "               if(dist[edge.to]>dist[v]+edge.cost){",
            "                   dist[edge.to]=dist[v]+edge.cost;",
            "                   que.emplace(dist[v]+edge.cost,edge.to);",
            "                   path[edge.to]=v;",
            "                }",
            "            }",
            "        }",
            "        pair<vector<ll>,vector<ll>> retpair;",
            "        retpair=make_pair(dist,path);",
            "        return retpair;",
            "       }",
            "    vector<ll> getpath(const vector<ll> &rec, ll goal){",
            "       vector<ll> path;",
            "       for(ll i=goal; i!=-1; i=rec[i]) path.push_back(i);",
            "       reverse(ALL(path));",
            "       return path;",
            "    }",
            "    void gridgraph(const vector<vector<ll>> &field, graph& gr) {",
            "       ll height=(ll)field.size();",
            "       ll width=(ll)field[0].size();",
            "       for(ll i=0;i<height;++i){",
            "           for(ll j=0;j<width;++j){",
            "               if(i-1>=0) gr.add_edge(i*width+j,(i-1)*width+j,field[i-1][j]);",
            "               if(i+1<height) gr.add_edge(i*width+j,(i+1)*width+j,field[i+1][j]);",
            "               if(j-1>=0) gr.add_edge(i*width+j,i*width+j-1,field[i][j-1]);",
            "               if(j+1<width) gr.add_edge(i*width+j,i*width+j+1,field[i][j+1]);",
            "            }",
            "        }",
            "    }",
            "};",
        ],
        "description": ""
    },
    "coordinate": {
		"scope": "C++,cpp",
		"prefix": "position",
		"body": [
            "struct position{",
            "    \tll x;",
            "    \tll y;",
            "};",
        ],
    },
    "createGraph": {
        "prefix": "createGraph",
        "body": [
            "struct createGraph{",
            "    vector<vector<ll>> graph;",
            "    createGraph(ll N) {",
            "        graph.resize(N);",
            "    }",
            "    void addEdge(ll from, ll to){",
            "        graph[from].emplace_back(to);",
            "    }",
            "    void addEdge(pair<ll,ll> pr){",
            "        graph[pr.first].emplace_back(pr.second);",
            "        graph[pr.second].emplace_back(pr.first);",
            "    }",
            "    void inputAndAddEdge(ll M){",
            "        set<pair<ll,ll>> checker;",
            "        pair<ll,ll> inserter;",
            "        rep(i,0,M){",
            "            ll from,to;",
            "            cin>>from>>to;",
            "            from--;to--;",
            "            inserter=make_pair(min(from,to),max(from,to));",
            "            if(checker.count(inserter)==0) {",
            "                addEdge(inserter);",
            "                checker.insert(inserter);",
            "            }",
            "        }",
            "    }",
            "    void showGrapgh(){",
            "        rep(i,0,graph.size()){",
            "            string out=to_string(i)+\":\";",
            "            rep(j,0,graph[i].size()) out+=to_string(graph[i][j])+\" \";",
            "            if(out.back()!=':') out.pop_back();",
            "            cout<<out<<endl;",
            "        }",
            "    }",
            "};",
            "",
            "",
            "",
        ],
        "description": ""
    }
}