{
	"UnionFind data structure": {
		"scope": "C++,cpp",
        "prefix": "UnionFind",
        "body": [
            "struct UnionFind {",
            "    vector<ll> parents;",
            "    vector<ll> roots;",
            "    vector<set<ll>> member;",
            "    UnionFind(int size) {",
            "        parents.assign(size, -1);",
            "        member = vector<set<ll>>(size);",
            "        rep(i, 0, size) {",
            "            roots.emplace_back(i);",
            "            member[i].emplace(i);",
            "        }",
            "    }",
            "    ll findRoot(ll x) {",
            "        if (parents[x] < 0) return x;",
            "        return parents[x] = findRoot(parents[x]);",
            "    }",
            "    bool unite(ll x, ll y) {",
            "        x = findRoot(x);",
            "        y = findRoot(y);",
            "        if (x == y) return false;",
            "        if (parents[x] > parents[y]) swap(x, y);",
            "        parents[x] += parents[y];",
            "        parents[y] = x;",
            "        iter_swap(lower_bound(ALL(roots), y), roots.end() - 1);",
            "        roots.pop_back();",
            "        sort(ALL(roots));",
            "        for (auto&& i : member[y]) member[x].emplace(i);",
            "        member[y].clear();",
            "        return true;",
            "    }",
            "    ll size(ll x) { return -parents[findRoot(x)]; }",
            "    bool isSameGroup(ll x, ll y) { return findRoot(x) == findRoot(y); }",
            "    ll getGroups() { return roots.size(); }",
            "    vector<ll> getMembers(ll x) {",
            "        vector<ll> v(ALL(member[findRoot(x)]));",
            "        return v;",
            "    }",
            "};",
        ],
	 	"description": "write UnionFind data structure"
	},
	"dijkstra": {
        "scope": "C++,cpp",
		"prefix": "dijkstra",
        "body": [
            "struct Edge{",
            "    ll to,cost;",
            "    Edge() {}",
            "    Edge(ll to, ll cost=0): to(to), cost(cost) {}",
            "};",
            "",
            "using P = pair<ll,ll>;",
            "struct graph{",
            "    const ll INF=numeric_limits<ll>::max();",
            "    vector<vector<Edge>> G;",
            "    ll n;",
            "    graph(ll N) {",
            "       n=N;",
            "       G.resize(n);",
            "    }",
            "    void add_edge(ll from, ll destination, ll cost) {",
            "       G[from].emplace_back(destination,cost); ",
            "    }",
            "    pair<vector<ll>,vector<ll>> dijkstra(ll start) {",
            "       vector<ll> dist(n,INF);",
            "       vector<ll> path(n,-1);",
            "       priority_queue<P,vector<P>,greater<P>> que;",
            "       dist[start]=0;",
            "       que.emplace(0,start);",
            "       while(!que.empty()){",
            "           P p=que.top();",
            "           que.pop();",
            "           ll v=p.second;",
            "           ll min_dist=p.first;",
            "           if(dist[v]<min_dist) continue;",
            "           for(Edge& edge:G[v]){",
            "               if(dist[edge.to]>dist[v]+edge.cost){",
            "                   dist[edge.to]=dist[v]+edge.cost;",
            "                   que.emplace(dist[v]+edge.cost,edge.to);",
            "                   path[edge.to]=v;",
            "                }",
            "            }",
            "        }",
            "        pair<vector<ll>,vector<ll>> retpair;",
            "        retpair=make_pair(dist,path);",
            "        return retpair;",
            "       }",
            "    vector<ll> getpath(const vector<ll> &rec, ll goal){",
            "       vector<ll> path;",
            "       for(ll i=goal; i!=-1; i=rec[i]) path.push_back(i);",
            "       reverse(ALL(path));",
            "       return path;",
            "    }",
            "    void gridgraph(const vector<vector<ll>> &field, graph& gr) {",
            "       ll height=(ll)field.size();",
            "       ll width=(ll)field[0].size();",
            "       for(ll i=0;i<height;++i){",
            "           for(ll j=0;j<width;++j){",
            "               if(i-1>=0) gr.add_edge(i*width+j,(i-1)*width+j,field[i-1][j]);",
            "               if(i+1<height) gr.add_edge(i*width+j,(i+1)*width+j,field[i+1][j]);",
            "               if(j-1>=0) gr.add_edge(i*width+j,i*width+j-1,field[i][j-1]);",
            "               if(j+1<width) gr.add_edge(i*width+j,i*width+j+1,field[i][j+1]);",
            "            }",
            "        }",
            "    }",
            "};",
        ],
        "description": ""
    },
    "primefactorize": {
        "prefix": "primefactorize",
        "body": [
            "vector<pair<ll,ll>> prime_factorize(ll Num){",
            "    ll lim=sqrt(Num)+1;",
            "    vector<pair<ll,ll>> pr; //pair<primenumber(素数),Exponentiation(べき数)>",
            "    vector<bool> listprime(lim);",
            "    for(ll i=0;i<lim;++i) listprime[i]=true;",
            "    ll root=sqrt(Num);",
            "    ll res=Num;",
            "    for(ll i=2;i<=root;++i){",
            "        ll expnum=0;",
            "        if(listprime[i]) {",
            "            while(res%i==0) {",
            "                res/=i;",
            "                expnum++;",
            "            }",
            "            for(ll j=i*2;j<=root;j+=i) listprime[j]=false;",
            "        }",
            "        if(expnum!=0) pr.emplace_back(make_pair(i,expnum));",
            "    }",
            "    if(res!=1) pr.emplace_back(make_pair(res,1));",
            "    return pr;",
            "}",
            "",
            "",
        ],
        "description": ""
    },
    "position": {
        "prefix": "position",
        "body": [
            "struct position{",
            "    ll x;",
            "    ll y;",
            "    position operator+(const position& other){",
            "        this->x+=other.x;",
            "        this->y+=other.y;",
            "        return *this;",
            "    }",
            "    position posin(){",
            "        ll x,y; cin>>x>>y; x--; y--;",
            "        this->x = x; this->y = y;",
            "        return *this;",
            "    }",
            "};",
        ],
        "description": ""
    },
    "lcm": {
        "scope": "C++,cpp",
        "prefix": "lcm",
        "body": [
            "ll gcd(ll a,ll b){",
            "    if(b==0) return a;",
            "    else return gcd(b,a%b);",
            "}",
            "",
            "ll lcm(ll a,ll b){ return a/gcd(a,b)*b;}",
        ],
        "description": ""
    },
    "gcd": {
        "prefix": "gcd",
        "body": [
            "ll gcd(ll a,ll b){",
            "    if(b==0) return a;",
            "    else return gcd(b,a%b);",
            "}",
        ],
        "description": ""
    },
    "createGraph": {
        "prefix": "createGraph",
        "body": [
            "struct createGraph{",
            "    vector<vector<ll>> graph;",
            "    createGraph(ll N) {",
            "        graph.resize(N);",
            "    }",
            "    void addEdge(ll from, ll to){",
            "        graph[from].emplace_back(to);",
            "    }",
            "    void addEdge(pair<ll,ll> pr){",
            "        graph[pr.first].emplace_back(pr.second);",
            "        graph[pr.second].emplace_back(pr.first);",
            "    }",
            "    void inputAndAddEdge(ll M){",
            "        set<pair<ll,ll>> checker;",
            "        pair<ll,ll> inserter;",
            "        rep(i,0,M){",
            "            ll from,to;",
            "            cin>>from>>to;",
            "            from--;to--;",
            "            inserter=make_pair(min(from,to),max(from,to));",
            "            if(checker.count(inserter)==0) {",
            "                addEdge(inserter);",
            "                checker.insert(inserter);",
            "            }",
            "        }",
            "    }",
            "    void showGrapgh(){",
            "        rep(i,0,graph.size()){",
            "            string out=to_string(i)+\":\";",
            "            rep(j,0,graph[i].size()) out+=to_string(graph[i][j])+\" \";",
            "            if(out.back()!=':') out.pop_back();",
            "            cout<<out<<endl;",
            "        }",
            "    }",
            "};",
        ],
        "description": ""
    },
    "grid": {
        "prefix": "grid",
        "body": [
            "template <class T>",
            "struct grid{",
            "    vector<vector<T>> field;",
            "    grid(ll height,ll width){field=vector<vector<T>>(height,vector<T>(width,(T)0));}",
            "    void input(){rep(i,0,field.size()) rep(j,0,field[i].size()) cin>>field[i][j];}",
            "    bool isIntheField(ll x,ll y,ll it){",
            "        ll nx = x + dx[it], ny = y + dy[it];",
            "        if(nx < 0 || ny < 0 || nx >= field[0].size() || ny >= field.size()) return false;",
            "        else return true;",
            "    }",
            "    bool isIntheField(ll x, ll y, ll it, T check){",
            "        ll nx = x + dx[it], ny = y + dy[it];",
            "        if(nx < 0 || ny < 0 || nx >= field[0].size() || ny >= field.size()) return false;",
            "        else if(field[ny][nx] == check) return false;",
            "        else return true;",
            "    }",
            "};",
        ],
        "description": ""
    }
}