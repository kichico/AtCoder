{
	"UnionFind data structure": {
		"scope": "C++,cpp",
		"prefix": "UnionFind",
		"body": [
			"struct UnionFind {",
				"\tvector<ll> parents;",
				"\tUnionFind(int size) { parents.assign(size, -1); }",
				"\tll findRoot(ll x) {",
					"\t\tif (parents[x] < 0) return x;",
					"\t\treturn parents[x] = findRoot(parents[x]);",
				"\t}",
				"\tbool unite(ll x, ll y) {",
					"\t\tx = findRoot(x);",
					"\t\ty = findRoot(y);",
					"\t\tif (x == y) return false;",
					"\t\tif (parents[x] > parents[y]) swap(x, y);",
					"\t\tparents[x] += parents[y];",
					"\t\tparents[y] = x;",
					"\t\treturn true;",
				"\t}",
				"\tll size(ll x) { return -parents[findRoot(x)]; }",
				"\tbool isSameGroup(ll x, ll y) { return findRoot(x) == findRoot(y); }",
			"};"
			],
	 	"description": "write UnionFind data structure"
	},
	"dijkstra": {
        "scope": "C++,cpp",
		"prefix": "dijkstra",
        "body": [
            "struct Edge{",
            "    \tll to,cost;",
            "    \tEdge() {}",
            "    \tEdge(ll to, ll cost=0): to(to), cost(cost) {}",
            "};",
            "",
            "typedef pair<ll,ll> P;",
            "struct graph{",
            "    \tconst ll INF=numeric_limits<ll>::max();",
            "    \tvector<vector<Edge>> G;",
            "    \tll n;",
            "    \tgraph(ll N) {",
            "        \t\tn=N;",
            "        \t\tG.resize(n);",
            "    \t}",
            "    \tvoid add_edge(ll from, ll destination, ll cost) {",
            "        \t\tG[from].emplace_back(destination,cost); ",
            "    \t}",
            "    \tpair<vector<ll>,vector<ll>> dijkstra(ll start) {",
            "        \t\tvector<ll> dist(n,INF);",
            "        \t\tvector<ll> path(n,-1);",
            "        \t\tpriority_queue<P,vector<P>,greater<P>> que;",
            "        \t\tdist[start]=0;",
            "        \t\tque.emplace(0,start);",
            "        \t\twhile(!que.empty()){",
            "            \t\t\tP p=que.top();",
            "            \t\t\tque.pop();",
            "            \t\t\tll v=p.second;",
            "            \t\t\tll min_dist=p.first;",
            "            \t\t\tif(dist[v]<min_dist) continue;",
            "            \t\t\tfor(Edge& edge:G[v]){",
            "                \t\t\t\tif(dist[edge.to]>dist[v]+edge.cost){",
            "                    \t\t\t\t\tdist[edge.to]=dist[v]+edge.cost;",
            "                    \t\t\t\t\tque.emplace(dist[v]+edge.cost,edge.to);",
            "                    \t\t\t\t\tpath[edge.to]=v;",
            "                \t\t\t\t}",
            "            \t\t\t}",
            "        \t\t}",
            "        \t\tpair<vector<ll>,vector<ll>> retpair;",
            "        \t\tretpair=make_pair(dist,path);",
            "        \t\treturn retpair;",
            "    \t}",
            "    \tvector<ll> getpath(const vector<ll> &rec, ll goal){",
            "        \t\tvector<ll> path;",
            "        \t\tfor(ll i=goal; i!=-1; i=rec[i]) path.push_back(i);",
            "        \t\treverse(ALL(path));",
            "        \t\treturn path;",
            "    \t}",
            "    \tvoid gridgraph(const vector<vector<ll>> &field, graph& gr) {",
            "        \t\tll height=(ll)field.size();",
            "        \t\tll width=(ll)field[0].size();",
            "        \t\tfor(ll i=0;i<height;++i){",
            "            \t\t\tfor(ll j=0;j<width;++j){",
            "                \t\t\t\tif(i-1>=0) gr.add_edge(i*width+j,(i-1)*width+j,field[i-1][j]);",
            "                \t\t\t\tif(i+1<height) gr.add_edge(i*width+j,(i+1)*width+j,field[i+1][j]);",
            "                \t\t\t\tif(j-1>=0) gr.add_edge(i*width+j,i*width+j-1,field[i][j-1]);",
            "                \t\t\t\tif(j+1<width) gr.add_edge(i*width+j,i*width+j+1,field[i][j+1]);",
            "            \t\t\t}",
            "        \t\t}",
            "    \t}",
            "};",
        ],
        "description": ""
    },
    "coordinate": {
		"scope": "C++,cpp",
		"prefix": "position",
		"body": [
            "struct position{",
            "    \tll x;",
            "    \tll y;",
            "};",
        ],
    }
}